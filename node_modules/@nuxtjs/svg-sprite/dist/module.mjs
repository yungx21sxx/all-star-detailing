import fsp from 'fs/promises';
import { defineNuxtModule, createResolver, resolveAlias, useLogger, addComponent, addServerHandler, addImports, addTemplate, addLayout, resolveModule, updateTemplates } from '@nuxt/kit';
import { optimize } from 'svgo';

const visitElements = (node, fn2) => {
  for (const child of node.children) {
    if (child.type === "element") {
      fn2(child, node);
      visitElements(child, fn2);
    }
  }
};
const fn = (root, params) => {
  const { onlyUnique = true } = params;
  const JSAPI = root.constructor;
  const uses = [];
  const useCounts = /* @__PURE__ */ new Map();
  const referencedElements = /* @__PURE__ */ new Map();
  visitElements(root, (node, parentNode) => {
    if (node.name === "use") {
      uses.push([node, parentNode]);
      const href = node.attributes["xlink:href"] || node.attributes.href;
      const count = useCounts.get(href) || 0;
      useCounts.set(href, count + 1);
    }
  });
  return {
    element: {
      enter: (node, parentNode) => {
        if (node.attributes.id == null) {
          return;
        }
        const href = `#${node.attributes.id}`;
        const count = useCounts.get(href);
        if (count == null) {
          return;
        }
        referencedElements.set(href, node);
        if (onlyUnique === false && count > 1) {
          delete node.attributes.id;
        }
        if (onlyUnique === true && count === 1) {
          parentNode.children = parentNode.children.filter(
            (child) => child !== node
          );
        }
      },
      exit(node, parentNode) {
        if (node.name === "defs") {
          if (onlyUnique === false || node.children.length === 0) {
            parentNode.children = parentNode.children.filter(
              (child) => child !== node
            );
          }
        }
      }
    },
    root: {
      exit: () => {
        for (const [use, useParentNode] of uses) {
          const href = use.attributes["xlink:href"] || use.attributes.href;
          const count = useCounts.get(href) || 0;
          const referenced = referencedElements.get(href);
          if (onlyUnique === true && count > 1) {
            continue;
          }
          if (referenced == null) {
            continue;
          }
          for (const [name, value] of Object.entries(use.attributes)) {
            if (name !== "x" && name !== "y" && name !== "xlink:href" && name !== "href") {
              referenced.attributes[name] = value;
            }
          }
          const x = use.attributes.x;
          const y = use.attributes.y;
          let attrValue = null;
          if (x != null && y != null) {
            attrValue = `translate(${x}, ${y})`;
          } else if (x != null) {
            attrValue = `translate(${x})`;
          }
          let replacement = referenced;
          if (attrValue != null) {
            const g = {
              type: "element",
              name: "g",
              attributes: {
                transform: attrValue
              },
              children: [referenced]
            };
            replacement = new JSAPI(g);
          }
          useParentNode.children = useParentNode.children.map((child) => {
            if (child === use) {
              return replacement;
            } else {
              return child;
            }
          });
        }
      }
    }
  };
};
const inlineDefs = {
  name: "inlineDefs",
  type: "visitor",
  active: true,
  description: "inlines svg definitions",
  params: { onlyUnique: false },
  fn
};

const spritesTemplate = {
  filename: "svg-sprite.mjs",
  getContents({ options }) {
    const imports = Object.keys(options.sprites).map((sprite) => `  "${sprite}": () => import("${options.outDir}/${sprite}.svg").then(r => r.default || r)`).join(",\n");
    return [
      "// Generated by @nuxtjs/svg-sprite",
      "export const sprites = {",
      imports,
      "}",
      'export const spriteClass = "";\n',
      'export const spriteClassPrefix = "";\n',
      `export const defaultSprite = "${options.defaultSprite}";
`
    ].join("\n");
  }
};
const iconsTemplate = {
  filename: "svg-sprite-icons.mjs",
  getContents({ options }) {
    const icons = Object.entries(options.sprites).flatMap(([name, values]) => {
      return values.map((icon) => `${name}/${icon.name}`);
    });
    return [
      "// Generated by @nuxtjs/svg-sprite",
      `export const icons = ${JSON.stringify(icons, null, 2)}
`
    ].join("\n");
  }
};

function useSvgFile(file, { defaultSprite = "icons" } = {}) {
  if (file.startsWith("svg:")) {
    file = file.substring(4);
  }
  const paths = file.split(":");
  const name = paths.pop().replace(/\.svg$/, "").toLocaleLowerCase().replace(/[^a-z0-9-:]/g, "-");
  const sprite = paths.join("-");
  return {
    name,
    sprite: sprite || defaultSprite
  };
}
function createSpritesManager(svgoOptions = {}) {
  const sprites = {};
  const addSvg = async (svg) => {
    svg = await optimizeSVG(svg, svgoOptions).then(extractDefs).then(convertToSymbol);
    sprites[svg.sprite] = (sprites[svg.sprite] || []).filter((s) => s.name !== svg.name);
    sprites[svg.sprite].push(svg);
  };
  const removeSvg = (sprite, name) => {
    sprites[sprite] = sprites[sprite] || [];
    sprites[sprite] = sprites[sprite].filter((s) => s.name !== name);
    if (sprites[sprite].length === 0) {
      delete sprites[sprite];
    }
  };
  const removeSprite = (sprite) => {
    delete sprites[sprite];
  };
  const generateSprite = (sprite) => {
    if (!sprites[sprite]) {
      return "";
    }
    const defs = sprites[sprite].map((svg) => svg.defs || "").join("");
    const contents = sprites[sprite].map((svg) => svg.content);
    return [
      '<?xml version="1.0" encoding="UTF-8"?>',
      '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">',
      `<defs>${defs}</defs>`,
      ...contents,
      "</svg>"
    ].join("\n");
  };
  return {
    sprites,
    addSvg,
    removeSvg,
    removeSprite,
    generateSprite
  };
}
function convertToSymbol(svg) {
  return {
    ...svg,
    content: svg.content.replace("<svg", `<symbol id="${svg.name}"`).replace("</svg>", "</symbol>").replace(/<defs>(.+)<\/defs>/, "")
  };
}
function extractDefs(svg) {
  return {
    ...svg,
    defs: svg.content.match(/<defs>(.+)<\/defs>/)?.[1] || ""
  };
}
async function optimizeSVG(svg, optimizeOptions = {}) {
  const plugins = optimizeOptions.plugins || [];
  const presetDefault = plugins.find((p) => p.name === "preset-default");
  presetDefault.params.overrides.cleanupIds = {
    ...presetDefault.params.overrides.cleanupIds,
    prefix: `${svg.name}-`
  };
  const $data = await optimize(svg.content, optimizeOptions);
  return {
    ...svg,
    content: $data.data
  };
}

const module = defineNuxtModule({
  meta: {
    name: "@nuxtjs/svg-sprite",
    configKey: "svgSprite",
    compatibility: {
      nuxt: ">=3.0.0"
    }
  },
  defaults: {
    input: "~/assets/sprite/svg",
    output: "~/assets/sprite/gen",
    defaultSprite: "icons",
    iconsPath: "/_icons",
    optimizeOptions: {
      plugins: [
        {
          name: "preset-default",
          params: {
            overrides: {
              removeViewBox: false,
              // Make all styles inline By definition, a defs sprite is not usable as a CSS sprite
              inlineStyles: {
                onlyMatchedOnce: false
              }
            }
          }
        },
        { name: "cleanupIds", params: {} },
        { name: "removeXMLNS" },
        // Disable removeViewBox plugin and enable removeDimensions
        { name: "removeDimensions" },
        // Enable removeAttrs plugin, Remove id attribute to prevent conflict with our id
        {
          name: "removeAttrs",
          params: {
            attrs: "svg:id"
          }
        },
        inlineDefs
      ]
    }
  },
  async setup(options, nuxt) {
    const { resolve } = createResolver(import.meta.url);
    const resolveRuntimeModule = (path) => resolveModule(path, { paths: resolve("./runtime") });
    const inputDir = resolveAlias(options.input, nuxt.options.alias);
    const outDir = resolveAlias(options.output, nuxt.options.alias);
    const logger = useLogger("svg-sprite");
    await addComponent({ name: "SvgIcon", filePath: resolve("./runtime/components/svg-icon.vue"), global: true });
    if (nuxt.options.dev) {
      nuxt.options.runtimeConfig.svgSprite = { inputDir, defaultSprite: options.defaultSprite };
      addServerHandler({ route: "/api/svg-sprite/generate", handler: resolve("./runtime/server/generate") });
      await addImports({ name: "useSprite", as: "useSprite", from: resolveRuntimeModule("./composables/useSprite.dev") });
    } else {
      await addImports({ name: "useSprite", as: "useSprite", from: resolveRuntimeModule("./composables/useSprite") });
    }
    const { sprites, addSvg, removeSvg, generateSprite } = createSpritesManager(options.optimizeOptions);
    nuxt.options.alias["#svg-sprite"] = addTemplate({
      ...spritesTemplate,
      write: true,
      options: {
        sprites,
        outDir,
        defaultSprite: options.defaultSprite
      }
    }).dst;
    if (options.iconsPath) {
      addLayout({
        filename: "svg-sprite.vue",
        src: resolve("./runtime/components/layout.vue")
      });
      nuxt.options.alias["#svg-sprite-icons"] = addTemplate({
        ...iconsTemplate,
        write: true,
        options: {
          sprites,
          outDir,
          defaultSprite: options.defaultSprite
        }
      }).dst;
      nuxt.hook("pages:extend", (routes) => {
        routes.unshift({
          name: "icons-page",
          path: options.iconsPath,
          file: resolve("runtime/components/icons-page.vue"),
          meta: {
            layout: "svg-sprite"
          }
        });
      });
    }
    nuxt.hook("nitro:init", async (nitro) => {
      const input = options.input.replace(/~|\.\//, "root").replace(/\//g, ":");
      const output = options.output.replace(/~\/|\.\//, "");
      if (!await nitro.storage.hasItem(`${output}:.gitignore`)) {
        await fsp.mkdir(`${nuxt.options.rootDir}/${output}`, { recursive: true });
        await fsp.writeFile(`${nuxt.options.rootDir}/${output}/.gitignore`, "*");
      }
      const svgsFiles = await nitro.storage.getKeys(input);
      await Promise.all(
        svgsFiles.map(async (file) => {
          file = file.substring(input.length + 1);
          const { name, sprite } = useSvgFile(file, { defaultSprite: options.defaultSprite });
          return addSvg({
            name,
            sprite,
            content: await nitro.storage.getItem(`${input}:${file}`)
          });
        })
      );
      const writeSprite = async (sprite) => {
        await fsp.writeFile(`${nuxt.options.rootDir}/${output}/${sprite}.svg`, generateSprite(sprite));
      };
      await Promise.all(Object.keys(sprites).map(writeSprite));
      if (!nuxt.options.dev) {
        return;
      }
      const handleFileChange = async (event, file) => {
        if (!file.startsWith(input)) {
          return;
        }
        file = file.substring(input.length + 1);
        const { name, sprite } = useSvgFile(file, { defaultSprite: options.defaultSprite });
        if (event === "update") {
          logger.log(`${file} changed`);
          await addSvg({
            name,
            sprite,
            content: await nitro.storage.getItem(`${input}:${file}`)
          });
        } else if (event === "remove") {
          logger.log(`${file} removed`);
          removeSvg(sprite, name);
        }
        await writeSprite(sprite);
        await updateTemplates({
          filter: (template) => template.filename?.startsWith("svg-sprite")
        });
      };
      nitro.storage.watch((event, file) => handleFileChange(event, file));
    });
  }
});

export { module as default };
