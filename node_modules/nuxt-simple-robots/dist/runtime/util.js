import { createDefu } from "defu";
import { withoutLeadingSlash } from "ufo";
export function parseRobotsTxt(s) {
  const groups = [];
  const sitemaps = [];
  let createNewGroup = false;
  let currentGroup = {
    comment: [],
    // comments are too hard to parse in a logical order, we'll just omit them
    disallow: [],
    allow: [],
    userAgent: []
  };
  for (const line of s.split("\n")) {
    const sepIndex = line.indexOf(":");
    if (sepIndex === -1)
      continue;
    const rule = line.substring(0, sepIndex).trim();
    const val = line.substring(sepIndex + 1).trim();
    switch (rule) {
      case "User-agent":
        if (createNewGroup) {
          groups.push({
            ...currentGroup
          });
          currentGroup = {
            comment: [],
            disallow: [],
            allow: [],
            userAgent: []
          };
          createNewGroup = false;
        }
        currentGroup.userAgent.push(val);
        break;
      case "Allow":
        currentGroup.allow.push(val);
        createNewGroup = true;
        break;
      case "Disallow":
        currentGroup.disallow.push(val);
        createNewGroup = true;
        break;
      case "Sitemap":
        sitemaps.push(val);
        break;
      case "Host":
        currentGroup.host = val;
        break;
      case "Clean-param":
        if (currentGroup.userAgent.includes("Yandex")) {
          currentGroup.cleanParam = currentGroup.cleanParam || [];
          currentGroup.cleanParam.push(val);
        }
        break;
    }
  }
  groups.push({
    ...currentGroup
  });
  return {
    groups,
    sitemaps
  };
}
function validateGroupRules(group, errors) {
  const toCheck = ["allow", "disallow"];
  toCheck.forEach((key) => {
    (group[key] || []).filter((rule) => {
      if (rule === "")
        return true;
      if (!rule.startsWith("/") && !rule.startsWith("*")) {
        errors.push(`Disallow rule "${rule}" must start with a \`/\` or be a \`*\`.`);
        return false;
      }
      return true;
    });
  });
}
export function validateRobots(robotsTxt) {
  const errors = [];
  robotsTxt.groups = robotsTxt.groups.filter((group) => {
    if (!group.allow.length && !group.disallow.length) {
      errors.push(`Group "${group.userAgent.join(", ")}" has no allow or disallow rules. You must provide one of either.`);
      return false;
    }
    validateGroupRules(group, errors);
    return true;
  });
  return errors;
}
export function asArray(v) {
  return typeof v === "undefined" ? [] : Array.isArray(v) ? v : [v];
}
export function indexableFromGroup(groups, path) {
  let indexable = true;
  const wildCardGroups = groups.filter((group) => asArray(group.userAgent).includes("*"));
  for (const group of wildCardGroups) {
    if (asArray(group.disallow).includes((rule) => rule === "/"))
      return false;
    const hasDisallowRule = asArray(group.disallow).filter((rule) => Boolean(rule)).some((rule) => path.startsWith(rule));
    const hasAllowRule = asArray(group.allow).some((rule) => path.startsWith(rule));
    if (hasDisallowRule && !hasAllowRule) {
      indexable = false;
      break;
    }
  }
  return indexable;
}
export function generateRobotsTxt({ groups, sitemaps }) {
  const lines = [];
  for (const group of groups) {
    for (const comment of group.comment || [])
      lines.push(`# ${comment}`);
    for (const userAgent of group.userAgent || ["*"])
      lines.push(`User-agent: ${userAgent}`);
    for (const allow of group.allow || [])
      lines.push(`Allow: ${allow}`);
    for (const disallow of group.disallow || [])
      lines.push(`Disallow: ${disallow}`);
    for (const cleanParam of group.cleanParam || [])
      lines.push(`Clean-param: ${cleanParam}`);
    lines.push("");
  }
  for (const sitemap of sitemaps)
    lines.push(`Sitemap: ${sitemap}`);
  return lines.join("\n");
}
const merger = createDefu((obj, key, value) => {
  if (Array.isArray(obj[key]) && Array.isArray(value))
    obj[key] = Array.from(/* @__PURE__ */ new Set([...obj[key], ...value]));
  return obj[key];
});
export function mergeOnKey(arr, key) {
  const res = {};
  arr.forEach((item) => {
    const k = item[key];
    res[k] = merger(item, res[k] || {});
  });
  return Object.values(res);
}
export function isInternalRoute(_path) {
  const path = withoutLeadingSlash(_path);
  if (path.startsWith(".") || path.startsWith("_"))
    return true;
  if (path.startsWith("cgi-bin") || path.startsWith("cdn-cgi") || path.startsWith("api"))
    return true;
  const lastSegment = path.split("/").pop() || path;
  return lastSegment.includes(".") || path.startsWith("@");
}
export function normaliseRobotsRouteRule(rules, defaultIndexable, disabledValue, enabledValue) {
  let isIndexingEnabled = defaultIndexable;
  let rule;
  if (typeof rules.robots === "boolean")
    isIndexingEnabled = rules.robots;
  else if (typeof rules.robots === "object" && typeof rules.robots.indexable !== "undefined")
    isIndexingEnabled = rules.robots.indexable;
  else if (typeof rules.robots === "object" && typeof rules.robots.rule !== "undefined")
    rule = rules.robots.rule;
  else if (typeof rules.robots === "string")
    rule = rules.robots;
  if (rule)
    isIndexingEnabled = !rule.includes("noindex");
  const indexable = (typeof rules.index === "undefined" || rules.index) && isIndexingEnabled;
  if (!rule)
    rule = indexable ? enabledValue : disabledValue;
  return {
    indexable,
    rule
  };
}
